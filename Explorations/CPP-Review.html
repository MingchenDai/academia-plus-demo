<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>Academia-Plus Theme Demo</title><meta name="author" content="Dimethyl"><link rel="shortcut icon" href="/academia-plus-demo/img/favicon.png"><link rel="stylesheet" href="/academia-plus-demo/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><script type="text/javascript"></script><script>(function(c,l,a,r,i,t,y){c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);})(window, document, "clarity", "script", "pzv2oojj02");</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-4VWYK5HQ0M"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-4VWYK5HQ0M');</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head><body><header id="page_header"><div class="header_wrap"><div id="blog_name"><a class="blog_title" id="site-name" href="/academia-plus-demo/">Academia-Plus Theme Demo</a></div><button class="menus_icon"><div class="navicon"></div></button><ul class="menus_items"><li class="menus_item"><a class="site-page" href="/academia-plus-demo/About"> About</a></li><li class="menus_item"><b class="sections"><a class="site-page" href="/academia-plus-demo/Explorations"> Explorations</a></b></li><li class="menus_item"><a class="site-page" href="/academia-plus-demo/Posts"> Posts</a></li><li class="menus_item"><a class="site-page" href="/academia-plus-demo/Publications"> Publications</a></li><li class="menus_item"><a class="site-page" href="/academia-plus-demo/Tags"> Tags</a></li></ul></div></header><main id="page_main"><div class="side-card sticky"><div class="card-wrap" itemscope itemtype="http://schema.org/Person"><div class="author-avatar"><img class="avatar-img" src="/academia-plus-demo/img/avatar.jpg" onerror="this.onerror=null;this.src='/academia-plus-demo/img/profile.png'" alt="avatar"></div><div class="author-discrip"><h3>Dimethyl</h3><p class="author-bio">Website Author Biography</p></div><div class="author-links"><button class="btn m-social-links">Links</button><ul class="social-icons"><li><a class="social-icon" href="https://github.com/MingchenDai/" target="_blank"><i class="fab fa-github" aria-hidden="true"></i></a></li><li><a class="social-icon" href="https://stackoverflow.com/users/28607451/mingchendai/" target="_blank"><i class="fab fa-stack-overflow" aria-hidden="true"></i></a></li><li><a class="social-icon" href="mailto:mingchendai@outlook.com" target="_blank"><i class="fas fa-envelope" aria-hidden="true"></i></a></li></ul></div></div></div><div class="page" itemscope itemtype="http://schema.org/CreativeWork"><h2 class="page-title">Explorations: C++ Review</h2><h3 class="page-subtitle">Key Points For CS1501 Final Exam</h3><tags><p> <i class="fas fa-tag"></i> <a href="/Tags/index.html#Explorations"><i>Explorations</i></a>	<i class="fas fa-tag"></i> <a href="/Tags/index.html#Program Language"><i>Program Language</i></a>	<i class="fas fa-tag"></i> <a href="/Tags/index.html#SJTU Courses"><i>SJTU Courses</i></a>	<br><b><i class="far fa-calendar"></i> 2025-02-02</b></p></tags><article><p>This is a document I organized while reviewing for my C++ final exam, focusing only on the key points.</p>
<h3><span id="introduction"> Introduction</span></h3>
<p>The three characteristics of algorithms: <strong>clear representation (unambiguous)</strong>, <strong>effectiveness</strong>, and <strong>finiteness</strong>.</p>
<p><strong>Compiler</strong>: A program that performs the translation task between high-level language and machine language.</p>
<h3><span id="basic-structure-of-a-program"> Basic Structure of a Program</span></h3>
<p>C++ compilation occurs in two stages: preprocessing and compilation. Preprocessing is done first, followed by compilation. Preprocessing commands usually begin with <code>#</code>.</p>
<p>Common preprocessing commands include <strong>library inclusion</strong>, and the corresponding information is provided by <strong>header files</strong>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;file&gt;</span> <span class="comment">// This library is a standard C++ library.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"file"</span> <span class="comment">// This library is a user-defined library. The compiler first looks in the user's directory for the corresponding file, and if not found, it will search the system's standard library directory.</span></span></span><br></pre></td></tr></table></figure>
<h4><span id="variables"> Variables</span></h4>
<p>Variable naming rules:</p>
<ol>
<li>Must start with a letter or an underscore.</li>
<li>Other characters must be letters, underscores, or digits; no spaces or other symbols; and letters are case-sensitive.</li>
<li>Cannot be a system reserved keyword.</li>
</ol>
<p>Assigning values to variables:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;           <span class="comment">// This is a valid assignment.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">a</span><span class="params">(<span class="number">5</span>)</span></span>;            <span class="comment">// This is a valid assignment.</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">5</span>, c; <span class="comment">// Some variables are assigned values while others are not.</span></span><br></pre></td></tr></table></figure>
<h4><span id="data-types"> Data Types</span></h4>
<p>Integers are represented in the computer in <strong>two’s complement</strong>. The two’s complement of a positive integer is its <strong>binary representation</strong>, and the two’s complement of a negative integer is the <strong>binary representation of its absolute value with bits inverted and 1 added</strong>.</p>
<p>Real numbers are stored in the computer in the form of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>×</mo><msup><mn>2</mn><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">a \times 2^b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> is called the mantissa, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> is the exponent. This is known as <strong>floating-point representation</strong>. A <code>float</code> guarantees at least <strong>6</strong> decimal digits of precision (4 bytes of space, 1 byte for the mantissa, and 3 bytes for the exponent). <code>double</code> and <code>long double</code> guarantee at least <strong>10</strong> decimal digits of precision (8 bytes of space, 3 bytes for the mantissa, and 5 bytes for the exponent). <strong>Computers cannot precisely represent real numbers.</strong></p>
<p>The ASCII values for characters ‘A’, ‘a’, and ‘0’ are 65, 97, and 48, respectively. A <code>char</code> occupies <strong>1</strong> byte of space to store the corresponding ASCII value.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="string">'A'</span>;</span><br><span class="line">cout &lt;&lt; a - <span class="number">1</span> &lt;&lt; endl; <span class="comment">// Outputs 64</span></span><br><span class="line">cout &lt;&lt; --a &lt;&lt; endl;   <span class="comment">// Outputs '@'</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;     <span class="comment">// Outputs '@'</span></span><br></pre></td></tr></table></figure>
<p>Boolean type variables occupy <strong>1</strong> byte and store values 0 (false) and 1 (true).</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> Bool = <span class="number">2</span>;</span><br><span class="line">Bool -= <span class="number">1</span>;</span><br><span class="line">cout &lt;&lt; Bool &lt;&lt; endl;     <span class="comment">// Outputs 0</span></span><br><span class="line">Bool -= <span class="number">1</span>;</span><br><span class="line">cout &lt;&lt; Bool &lt;&lt; endl;     <span class="comment">// Outputs 1</span></span><br><span class="line">cout &lt;&lt; <span class="number">1</span> + Bool &lt;&lt; endl; <span class="comment">// Outputs 2</span></span><br></pre></td></tr></table></figure>
<p>Enumerations can only perform assignment and comparison operations. <code>bool</code> is a pre-defined enumeration in C++, but can also perform arithmetic, relational, and logical operations.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">weekdayT</span> { Sunday = <span class="number">1</span>, Monday, Tuesday = <span class="number">10</span>, Wednesday, Thursday, Friday, Saturday };</span><br></pre></td></tr></table></figure>
<p>Type aliases:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INTEGER;</span><br><span class="line"><span class="type">int</span> a;     <span class="comment">// Valid</span></span><br><span class="line">INTEGER b; <span class="comment">// Valid</span></span><br></pre></td></tr></table></figure>
<p>Size of types or variables:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; endl;      <span class="comment">// Returns 4</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="string">'a'</span> + <span class="number">15</span>) &lt;&lt; endl; <span class="comment">// Returns 4</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(x) &lt;&lt; endl;        <span class="comment">// Returns 4</span></span><br></pre></td></tr></table></figure>
<h4><span id="constants-and-symbolic-constants"> Constants and Symbolic Constants</span></h4>
<p>Integer constants are automatically represented as either <code>int</code> or <code>long int</code> based on their value. To force an integer to be treated as a long integer, append an <code>l</code> or <code>L</code> to the number, such as <code>100L</code>. Octal numbers start with <code>0</code>, and hexadecimal numbers start with <code>0x</code>.</p>
<p>Floating-point constants have two representations: <strong>decimal</strong> and <strong>scientific</strong> notation. Scientific notation is represented as <code>aeb</code> or <code>aEb</code>, for example, <code>123e4</code> or <code>123E4</code>. Note that <code>e</code> or <code>E</code> must <strong>have digits on both sides</strong>, and the number after <code>e</code> or <code>E</code> must be an <strong>integer</strong>. In C++, floating-point constants are treated as <code>double</code> by default. To treat a floating-point constant as float, append <code>F</code> to the number, like <code>123.4F</code>.</p>
<p>Character constants are enclosed in single quotes. Non-printable characters can be represented using escape sequences. A character constant can be stored in a char variable, but a char variable cannot store in a string.</p>
<p>C-style symbolic constants are simple text replacements and may lead to errors. A <code>const</code> symbolic constant can only be assigned an initial value at the time of definition, and its value cannot be changed later.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14        <span class="comment">// C-style</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> PI = <span class="number">3.14</span>; <span class="comment">// C++ style</span></span><br></pre></td></tr></table></figure>
<h4><span id="extension"> *Extension</span></h4>
<p><code>long long int</code> occupies <strong>8</strong> bytes.</p>
<p>The <code>auto</code> type can automatically deduce the variable’s type, but the variable must be initialized. <code>decltype</code> can also deduce the type from an expression without evaluating it.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> c = <span class="string">'a'</span>;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="keyword">decltype</span>(a + b) d;</span><br></pre></td></tr></table></figure>
<p>A constant expression is one whose value is determined at compile time and cannot change. C++ allows declaring variables as <code>constexpr</code> to inform the compiler to verify that their value is a constant at compile time.</p>
<p><code>using</code> can be used to declare type aliases, similar to <code>typedef</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> REAL = <span class="type">double</span>;</span><br></pre></td></tr></table></figure>
<h4><span id="input-and-output"> Input and Output</span></h4>
<p>The <code>get</code> function is used as <code>cin.get(character variable);</code> or <code>character variable = cin.get();</code>.</p>
<h4><span id="arithmetic-operations"> Arithmetic Operations</span></h4>
<p>The <code>%</code>, <code>/</code>, and <code>*</code> operators have the same priority level.</p>
<p>C++ only performs operations between operands of the same type. When performing operations between different types, <strong>automatic type conversion</strong> occurs, with the general rule being: <strong>non-standard types are converted to standard types</strong>, <strong>smaller data types are converted to larger types</strong>, <strong>and smaller numerical ranges are converted to larger ranges</strong>.</p>
<p>Non-standard integer types such as <code>bool</code>, <code>char</code>, and <code>short</code> are first converted to <code>int</code> before performing arithmetic operations.</p>
<p>When a real number is converted to an integer, the fractional part is discarded. When an integer is converted to a real number, its value remains the same but is represented as a floating-point number. When an integer is converted to a character type, the least significant <strong>8</strong> bits of the integer are used.</p>
<p>The form of explicit type casting is:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span>(a / b);</span><br><span class="line">(<span class="type">float</span>)(a / b);</span><br><span class="line">(<span class="type">float</span>)a / b;</span><br><span class="line">a / (<span class="type">float</span>)b;</span><br></pre></td></tr></table></figure>
<p>There are four types of explicit type casts: <code>static_cast</code>, <code>reinterpret_cast</code>, <code>const_cast</code>, and <code>dynamic_cast</code>. The syntax for casting is <code>cast_type&lt;Type&gt;(expression)</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">int</span> d = <span class="number">10</span>;</span><br><span class="line">ch = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(d);</span><br></pre></td></tr></table></figure>
<p>When dividing integers, the result is truncated, regardless of whether the numbers are positive or negative.</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi mathvariant="normal">%</mi><mo stretchy="false">(</mo><mo>−</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">m \% (-n) = m % n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord">%</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>−</mo><mi>m</mi><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>n</mi><mo>=</mo><mo>−</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">(-m) \% n = -m % n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord mathnormal">m</span></span></span></span>.</p>
<h4><span id="assignment-operations"> Assignment Operations</span></h4>
<p>In an assignment expression, the left side is the <strong>left value</strong>, and the right side is the <strong>right value</strong>. The left value must be a memory location that stores data, while the right value is disposable after being used. When the left and right sides have different types, automatic type conversion occurs.</p>
<p>The result of an assignment expression is the right value. Assignment and compound assignment operators are <strong>right-associative</strong>, and their priority is lower than arithmetic operators.</p>
<p><code>x++</code> means the original value of <code>x</code> participates in the operation, and <code>x</code> is incremented afterward. <code>++x</code> means <code>x</code> is incremented first, and then the new value of <code>x</code> participates in the operation.</p>
<h3><span id="branch"> Branch</span></h3>
<h4><span id="relational-expressions"> Relational Expressions</span></h4>
<p>The operators <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> have the same priority level, and <code>==</code>, <code>!=</code> also have the same priority, but the first four have higher priority than the last two. When relational operators are combined with arithmetic operators, <strong>arithmetic operations are performed first</strong>. When relational operators are combined with assignment operators, <strong>relational operations are performed first</strong>. Relational operators are <strong>left-associative</strong>.</p>
<p>Relational expressions also undergo automatic type conversion, and the result is of type <code>bool</code>.</p>
<h4><span id="logical-expressions"> Logical Expressions</span></h4>
<p><code>!</code> is a unary operator, while <code>&amp;&amp;</code> and <code>||</code> are binary operators. The priority order is: <code>!</code> &gt; arithmetic operators &gt; relational operators &gt; <code>&amp;&amp;</code> &gt; <code>||</code> &gt; assignment operators.</p>
<h4><span id="conditional-expressions"> Conditional Expressions</span></h4>
<p>The conditional expression format is: <code>(condition)? expression1 : expression2</code>.</p>
<h4><span id="switch-statement"> <code>switch</code> Statement</span></h4>
<p>The <code>default</code> clause is <strong>optional</strong>. The <code>case</code> label must be an <strong>integer constant expression</strong> (which can be <code>int</code>, <code>char</code>, or an enumeration type).</p>
<h3><span id="loop"> Loop</span></h3>
<p>For list iteration: <code>for(int i : {1, 2, 3, 4, 3, 2, 1})</code>, where elements in the list can also be expressions.</p>
<p><code>break</code> jumps out of the loop, while <code>continue</code> skips the current iteration and goes to the next iteration.</p>
<h3><span id="array"> Array</span></h3>
<p><strong>The number of array elements cannot be a variable.</strong> Some compilers may compile this successfully due to compiler optimizations, but it is not universal.</p>
<p>When defining an array, you can assign initial values to all elements, or just some of them. Elements that are not assigned an initial value will have a default value of 0.</p>
<p>When assigning initial values to all elements, the array size can be omitted, and the system will determine the size based on the number of given initial values.</p>
<p><strong>C++ does not check the validity of array subscripts.</strong></p>
<p>You can use a range-based <code>for</code> loop to access array elements.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x : a) {  <span class="comment">// Or: for(auto x : a)</span></span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4><span id="string-input-and-output"> String Input and Output</span></h4>
<p><code>cin.getline(char array, array size, delimiter)</code> where the delimiter can be omitted, and the default is the newline character.</p>
<h3><span id="functions"> Functions</span></h3>
<p>A function’s return statement can be <code>return expr</code> or <code>return(expr)</code>. C++ functions can only have <strong>one</strong> return value per execution and cannot return a <strong>complete array</strong>.</p>
<p><strong>The function name is an identifier</strong> that follows <a href="#variables">the identifier naming rules</a>.</p>
<p>The called function cannot access the local variables of the calling function.</p>
<h4><span id="parameter-passing-in-function"> Parameter Passing in Function</span></h4>
<p>In C++, parameters can be passed by <strong>value</strong> or <strong>reference</strong>.</p>
<p>In value passing, the actual parameters can be constants, variables, expressions, or other function calls. During the function call, the actual parameters are calculated first, and then passed (the corresponding formal parameters are initialized, and type conversion occurs automatically if types do not match). If multiple actual parameters are expressions, <strong>the order of evaluation is determined by the specific compiler.</strong></p>
<p>When a function is called, the system allocates a memory space for it, called a <strong>frame</strong>. When the function finishes executing, the system reclaims the memory allocated for the function.</p>
<p>Global variables are shadowed in the local scope. If you need to access them, use the <strong>scope resolution operator</strong> <code>::</code>.</p>
<h5><span id="arrays-as-function-parameters"> Arrays as Function Parameters</span></h5>
<p>When passing arrays to functions, the address of the array’s start is passed. The formal and actual parameters are <strong>the same</strong> array. Therefore, the size of the array in the parameters is meaningless and can be omitted.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> array[<span class="number">10</span>])</span></span>;  <span class="comment">// Valid</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> array[])</span></span>;    <span class="comment">// Valid</span></span><br></pre></td></tr></table></figure>
<h4><span id="variable-storage-classes"> Variable Storage Classes</span></h4>
<p>Variables can be classified as automatic (<code>auto</code>), static (<code>static</code>), register (<code>register</code>), or external (<code>extern</code>).</p>
<h5><span id="automatic-variables"> Automatic Variables</span></h5>
<p>Local variables, formal parameters, or variables defined in program blocks are automatic variables if not explicitly declared as another storage type. These variables are stored in the memory area called the <strong>stack</strong>. When a function is called, the system allocates a memory block in the stack for the function, called a <strong>frame</strong>, where all the automatic variables for that function are stored. Once the function finishes executing, the system <strong>automatically</strong> reclaims the memory.</p>
<h5><span id="static-variables"> Static Variables</span></h5>
<p>Variables declared as <code>static</code> are called <strong>static variables</strong>. Both local and global variables can be static. Adding the <code>static</code> keyword to a global variable indicates that the variable is <strong>private to the current source file</strong>, and <strong>cannot be accessed by functions in other source files</strong>. Static global variables are stored in the <strong>global variable section</strong>, and the variable does not disappear when the function finishes executing. On the next function call, it uses the <strong>previous value</strong>.</p>
<p>Static variables that are not initialized by the programmer are initialized by the system to <strong>0</strong> (for <code>char</code> types, it is <code>\0</code>, and for strings). Local static variables persist after the function call, but they cannot be accessed by other functions.</p>
<p>Local static variables will be destroyed after the program finishes executing. If both static local variables and global variables exist in the program, the static local variables are destroyed first, followed by global variables.</p>
<p>A function can also be declared as <code>static</code>, meaning it can only be called by other functions in the same source file.</p>
<h5><span id="register-variables"> Register Variables</span></h5>
<p>A <strong>register variable</strong> is a variable stored directly in the CPU registers, declared using the <code>register</code> keyword. If no suitable registers are available in the system, the compiler treats it as an automatic variable. In modern compilers, programmers generally do not need to specify this; the compiler decides whether to use a register for a variable as part of its optimization process.</p>
<h5><span id="external-variables"> External Variables</span></h5>
<p>If a global variable defined in another function or source file is needed, the variable must be declared using the keyword <code>extern</code> for <strong>external variable declaration</strong>. This is mainly to allow global variables to be shared among multiple source files. The <strong>type name can be omitted</strong> when declaring external variables.</p>
<p><strong>External variables must be global variables.</strong></p>
<p><strong>Distinguish between declaration and definition.</strong> A definition allocates memory for the variable based on its data type, while a declaration only specifies how the variable should be used, without allocating memory (similar to a function prototype declaration).</p>
<h4><span id="default-arguments-for-functions"> Default Arguments for Functions</span></h4>
<p>Default values for parameters only make sense in function declarations, so the compiler disallows <strong>defining default arguments in both the declaration and definition</strong>.</p>
<p>Once a default value is assigned to one parameter, all subsequent parameters must also have default values.</p>
<p>It is best to specify default values in the function declaration. Also, different source files can assign different default values to function parameters, but in the same source file, each parameter can only have one default value.</p>
<h4><span id="inline-functions"> Inline Functions</span></h4>
<p>When compiling, the compiler may copy the code of an inline function to the calling site to avoid the function call, but this may lead to multiple copies of the function’s code, increasing the size of the target code. To define an inline function, add the <code>inline</code> keyword before the return type. Inline functions are just a suggestion to the compiler; it may decide to handle them differently based on the situation.</p>
<p><strong>Inline functions cannot be recursive.</strong></p>
<h4><span id="function-overloading"> Function Overloading</span></h4>
<p>Function overloading allows functions with the same name to differ in the number of parameters, the types of parameters, or both.</p>
<h4><span id="function-templates"> Function Templates</span></h4>
<p>A function template allows some form parameters to have variable types, called <strong>template parameters</strong>. When calling the function, the actual parameter types determine the values of the template parameters, and the actual parameter types replace the template parameters to generate different <strong>template functions</strong>, a process called <strong>template instantiation</strong>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>If some template parameters do not appear in the function’s formal parameter list, <strong>explicitly specify template arguments</strong>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">calc</span>&lt;<span class="type">int</span>, <span class="type">char</span>, <span class="type">int</span>&gt;(<span class="number">5</span>, <span class="string">'a'</span>);</span><br></pre></td></tr></table></figure>
<h4><span id="trailing-return-type"> *Trailing Return Type</span></h4>
<p>The compiler can automatically deduce the return type of a function.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type1</span>, <span class="keyword">class</span> <span class="title class_">Type2</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">cal</span><span class="params">(Type1 alpha, Type2 beta)</span> -&gt; <span class="title">decltype</span><span class="params">(alpha + beta)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> alpha + beta;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3><span id="pointers"> Pointers</span></h3>
<p>C++ does not allow assignment between pointers of different types. If necessary, use explicit type casting.</p>
<p>You can declare a pointer of the <code>void</code> type (a <strong>generic pointer type</strong>), which just indicates that the pointer holds an address, without specifying what type of data is stored at that address. <code>void</code> pointers can be assigned to pointers of any type.</p>
<p><strong>Constant Pointer</strong>: A pointer to a constant <code>const int *p = &amp;x</code> (<code>*p</code> cannot be modified, but <code>p</code> can be modified).</p>
<p><strong>Pointer Constant</strong>: A constant pointer <code>int *const p = &amp;x</code> (<code>*p</code> can be modified, but <code>p</code> cannot be modified).</p>
<p><strong>Constant Pointer Constant</strong>: A constant pointer to a constant <code>const int *const p = &amp;x</code> (<code>*p</code> and <code>p</code> cannot be modified).</p>
<h4><span id="dynamic-memory-allocation"> Dynamic Memory Allocation</span></h4>
<p>The <code>new</code> operator allocates memory for a specific data type on the heap, and the result is <strong>the address of this memory block</strong> (if the allocation fails, it returns a <strong>null pointer</strong>).</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>);  <span class="comment">// Can specify an initial value</span></span><br><span class="line">*p = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>The <code>delete</code> operator can be used to free the memory that the pointer points to, and <code>delete[] p</code> is used to free the memory of an array when the pointer holds the address of an array.</p>
<p>Dynamic arrays can also be initialized with a list of values.</p>
<h4><span id="pointers-and-functions"> Pointers and Functions</span></h4>
<p>If a function returns a pointer, just add a <code>*</code> before the function name.</p>
<p>You can define reference types using <code>int &amp;j = i</code>. Reference types require the <code>&amp;</code> symbol before the variable name and must immediately specify an initial value. Both the reference and the original variable share the same memory space. Once a variable is defined as a reference to another variable, it cannot be used as a reference to another variable.</p>
<p>If a reference is constant (i.e., <code>const int &amp;a</code>), the reference variable’s initial value can be a constant.</p>
<p>You can use <code>for(int &amp;k : a)</code> to access and modify each element of an array.</p>
<p>When using reference parameters, the actual argument passed must be a left-value expression.</p>
<p>A function that returns a reference can make the function call appear as a left-value, but it cannot return a <strong>local variable</strong> (as it will result in an invalid reference since local variables are destroyed).</p>
<p>You can use <code>&amp;&amp;</code> to declare a r-value reference, which refers to a temporary value that will be destroyed.</p>
<h4><span id="main-function"> *<code>main</code> Function</span></h4>
<p>The <code>main</code> function has two formal parameters: <code>argc</code> represents the number of command-line arguments when the program is run, and <code>argv</code> is an array of pointers to characters, where each element is a pointer to an actual argument, and each actual argument is represented as a string.</p>
<h4><span id="function-pointers"> Function Pointers</span></h4>
<p>The format is <code>return_type (*pointer_variable)(parameter_list);</code>. You can assign values to the pointer by using <code>pointer_variable = function_name</code>.</p>
<h4><span id="lambda-expressions"> *Lambda Expressions</span></h4>
<p>A lambda expression is an unnamed inline function with a return type, a parameter list, and a function body.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> { <span class="type">int</span> z = x + y; <span class="keyword">return</span> z; }</span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> { <span class="type">int</span> z = x + y; <span class="keyword">return</span> z; }; <span class="comment">// Assign lambda to a function pointer</span></span><br></pre></td></tr></table></figure>
<p>Lambda expressions allow access to other variables in the containing function, which is called <strong>capture</strong>.</p>
<p>Capture forms: capture specific variables by value (<code>x</code>), capture all variables by value (<code>=</code>), capture specific variables by reference (<code>&amp;x</code>), or capture all variables by reference (<code>&amp;</code>).</p>
<h3><span id="structures-and-modularity"> Structures and Modularity</span></h3>
<p>Pointer to a structure: <code>(*sp).item</code> or <code>sp-&gt;item</code>.</p>
<p>Preprocessing commands:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span></span></span><br><span class="line"><span class="comment">//Contents</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3><span id="creating-new-types"> Creating New Types</span></h3>
<p>Private members can only be accessed by member functions of the same class, not by global functions or member functions of other classes. Public members can be accessed using <code>object_name.member_name</code>.</p>
<p>If access specifiers are not specified, the member is <strong>private</strong> by default.</p>
<p>Functions defined directly within a class are <strong>inline functions</strong> by default.</p>
<p>Member functions can access the private members of the class and can use <code>object_name.member_name</code> to access any member of another object of the same class.</p>
<p>If <code>rp</code> is a pointer to an object of a class, the corresponding object can be accessed using <code>rp-&gt;function()</code>. Objects of the same class can assign values to each other.</p>
<h4><span id="this-pointer"> <code>this</code> Pointer</span></h4>
<p>There is only one copy of a member function in memory, and all objects share this copy.</p>
<p>When a member function is called through an object, the compiler passes the address of the object to the parameter <code>this</code>. The member function can then access which object it is acting upon using <code>this</code>. Normally, you can omit <code>this</code> when writing member functions, but if accessing the whole object, you must explicitly use the <code>this</code> pointer, i.e., <code>*this</code>.</p>
<h4><span id="constructors-and-destructors"> Constructors and Destructors</span></h4>
<p>In C++, the constructor’s name is the same as the class name, and it cannot have a return type. Constructors can be overloaded.</p>
<p>When the data member is not a basic type but an object of another class, and it cannot be directly initialized in the constructor body, it can be initialized in the initialization list. <strong>Constant data members</strong> must also be initialized in the initialization list. The initialization order is based on the order of the data members’ definitions. To force the generation of the default constructor, you can declare it as <code>ClassName() = default;</code>.</p>
<p>When creating an object, you can use an object of the same class to initialize it, which uses the <strong>copy constructor</strong>. The prototype is <code>ClassName(const ClassName&amp;)</code>. The <strong>default copy constructor</strong> will create a copy of the object with the same values. If assignment through copy construction is not allowed, it can be declared as <code>ClassName(const ClassName&amp;) = delete;</code>.</p>
<p>The destructor’s prototype is <code>~ClassName()</code>, and it has no parameters or return value.</p>
<p>C++ allows a constructor to call another constructor, called <strong>delegating constructors</strong>.</p>
<h4><span id="constants-and-classes"> Constants and Classes</span></h4>
<p>You can define a <strong>constant member function</strong> to be called by constant objects. The declaration of a constant member function is done by adding <code>const</code> after the function signature.</p>
<h4><span id="static-data-members-and-member-functions"> Static Data Members and Member Functions</span></h4>
<p>A class’s static data members have a separate data storage area, and they can be public or private.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sample</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> rate;</span><br><span class="line">};</span><br><span class="line"><span class="type">double</span> Sample::rate = <span class="number">0.05</span>;</span><br></pre></td></tr></table></figure>
<p>Static member functions are used to operate on static data members and serve the class rather than the objects of the class. When defined outside the class, the <code>static</code> keyword is not required. Static member functions do not have an implicit <code>this</code> pointer, so they can only access static data members or other static member functions.</p>
<p>Static constant members are declared using <code>static const</code>. Constant data members belong to each object; static constant data members belong to the entire class. Static constant data members must be initialized in the class definition.</p>
<h4><span id="friend-functions-and-classes"> Friend Functions and Classes</span></h4>
<p>You can specify that certain global functions, all member functions of another class, or a specific member function of another class are allowed to directly access the private members of a class. These are called <strong>friend functions</strong>, <strong>friend classes</strong>, and <strong>friend member functions</strong>, collectively known as <strong>friends</strong>.</p>
<p>To declare a function as a friend, you declare it within the class definition using the keyword <code>friend</code>. This declaration can be placed in either the public or private section.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">int</span> <span class="title">B::function</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>Friend relationships are <strong>not symmetric</strong> and <strong>not transitive</strong>.</p>
<h3><span id="operator-overloading"> Operator Overloading</span></h3>
<p>In C++, the overloaded function name is <code>operator@</code>, and the implicit <code>this</code> pointer is the first parameter of the operator.</p>
<p>The <code>=</code>, <code>[]</code>, <code>()</code>, and <code>-&gt;</code> operators must be overloaded as member functions. The postfix operator overload function takes an extra <code>int</code> parameter, which is unused. When the postfix operator is called, the compiler uses 0 as the value for this parameter. The prefix operator uses the regular overloaded function.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Sample &amp;Sample::<span class="keyword">operator</span>=(<span class="type">const</span> Sample &amp;right) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;right) {</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//Contents</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> &amp;Sample::<span class="keyword">operator</span>[](<span class="type">int</span> index) {</span><br><span class="line">    <span class="comment">//Contents</span></span><br><span class="line">    <span class="keyword">return</span> a[index];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Sample &amp;Sample::<span class="keyword">operator</span>++() {</span><br><span class="line">    <span class="comment">//Contents</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Sample Sample::<span class="keyword">operator</span>++(<span class="type">int</span> x) {</span><br><span class="line">    <span class="comment">//Contents</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> ClassType &amp;obj) {</span><br><span class="line">    os &lt;&lt; Content;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;is, <span class="type">const</span> ClassType &amp;obj) {</span><br><span class="line">    is &gt;&gt; content;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>Adding <code>explicit</code> before the constructor prevents implicit type conversion. To perform the conversion, objects must be explicitly constructed.</p>
<p>Type conversion functions must be defined as member functions of the class. They tell C++ how to convert the current class type object to another type. Adding <code>explicit</code> before the conversion operator prevents implicit type conversion but supports explicit type conversion.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="comment">// Contents</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3><span id="composition-and-inheritance"> Composition and Inheritance</span></h3>
<p>If a data member of a class is an object of another class, the member is called an <strong>object member</strong>.</p>
<p>An existing class is called the <strong>base class</strong> or <strong>parent class</strong>, and a new class derived from it is called the <strong>derived class</strong> or <strong>child class</strong>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {};</span><br></pre></td></tr></table></figure>
<p>Base and derived classes are two independent classes. Therefore, a member function of the derived class cannot access the private members of the base class. The <code>protected</code> access modifier is a special type of private member that cannot be accessed by global functions or member functions of other classes but can be accessed by member functions and friend functions of derived classes.</p>
<p>The derived class constructor body is responsible for initializing new data members. The base class’s constructor is called in the initialization list to initialize the base class’s data members. The base class portion of a derived class object is destroyed by the base class destructor. The destructor of the derived class automatically calls the base class destructor, with the derived class destructor executing first.</p>
<p>You can assign a derived class object to a base class object. When a base class pointer points to a derived class object, it can only access the base class portion of the derived class. When a base class reference is used to reference a derived class object, it can only modify the base class portion.</p>
<p>To assign a base class pointer to a derived class pointer, you should use explicit type casting, such as <code>reinterpret_cast</code>.</p>
<h4><span id="virtual-functions"> Virtual Functions</span></h4>
<p>A <strong>virtual function</strong> is a function in the class definition that is declared with the <code>virtual</code> keyword. When redefining it in the derived class, its function prototype must match exactly with the base class’s virtual function, otherwise the compiler will treat the derived class’s function as an overloaded function.</p>
<p>When overriding, <code>virtual</code> can be included or omitted, but it’s recommended to add it.</p>
<p>Constructors cannot be virtual, but destructors can be, and it’s best to declare them as virtual.</p>
<p>A <strong>pure virtual function</strong> is a virtual function that is declared in the base class without being defined, but it must be defined in the derived class.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>If a class contains at least one pure virtual function, it is called an <strong>abstract class</strong>. Abstract classes cannot have objects directly instantiated, but pointers to abstract classes can point to derived class objects.</p>
</article></div></main><div class="nav-wrap"><div class="nav"><button class="site-nav"><div class="navicon"></div></button><ul class="nav_items"><li class="nav_item"><a class="nav-page" href="/academia-plus-demo/About"> About</a></li><li class="nav_item"><a class="nav-page" href="/academia-plus-demo/Explorations"> Explorations</a></li><li class="nav_item"><a class="nav-page" href="/academia-plus-demo/Posts"> Posts</a></li><li class="nav_item"><a class="nav-page" href="/academia-plus-demo/Publications"> Publications</a></li><li class="nav_item"><a class="nav-page" href="/academia-plus-demo/Tags"> Tags</a></li></ul></div><div class="cd-top"><i class="fa fa-arrow-up" aria-hidden="true"></i></div></div><footer id="page_footer"><div class="footer_wrap"><div class="copyright">&copy;2024 - 2025 by Dimethyl</div><div class="theme-info">Powered by <a target="_blank" href="https://hexo.io" rel="nofollow noopener">Hexo</a> & <a target="_blank" href="https://github.com/MingchenDai/hexo-theme-academia-plus" rel="nofollow noopener">Academia-Plus Theme</a>, a refined version of <a target="_blank" href="https://github.com/PhosphorW/hexo-theme-academia" rel="nofollow noopener">Academia Theme</a>.</div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery-pjax@latest/jquery.pjax.min.js"></script><script src="/academia-plus-demo/js/main.js"></script></body></html>